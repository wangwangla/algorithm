# ArrayList

啥也没说的写了第7了，这是第一个要看的对象了。

## 简单案例

```java
ArrayList arrayList = new ArrayList();
arrayList.add(10);
arrayList.add(11);
arrayList.add(12);
arrayList.add(13);
arrayList.remove(0);
System.out.println(arrayList.toString());
Iterator iterator = arrayList.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

## 自己如何设计

为了可以随机访问  实现RandomAccess
为了可以克隆，  实现cloneable
为了序列化    实现……
通常的方法书写  写一个接口    公共的方法所加一个抽象类


还是看源码吧

## 成员变量

```java
默认 大小
private static final int DEFAULT_CAPACITY = 10;

//空数组
private static final Object[] EMPTY_ELEMENTDATA = {};

默认的空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

transient序列化的时候不进行序列化
transient Object[] elementData; // non-private to simplify nested class access
数组的大小
private int size;
```



## 构造函数

三个构造

```java
//没有参数的，使用默认的空数组
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

/**
 * 有参数的
 * 1.如果大于0，那么就创建一个指定大小的数组
 * 2.如果等于0，就给一个空数组（不同于默认的空数组）
 * 3.小于0，抛出异常
 */
public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}

/**
 * 传入集合，如果集合数据不等于0
 * 1.如果是ArrayList，那就将data给条目
 * 2.复制数组的值
 * 等于0，那么就给一个空数组。
 */
public ArrayList(Collection<? extends E> c) {
    Object[] a = c.toArray();
    if ((size = a.length) != 0) {
        if (c.getClass() == ArrayList.class) {
            elementData = a;
        } else {
            elementData = Arrays.copyOf(a, size, Object[].class);
        }
    } else {
        // replace with empty array.
        elementData = EMPTY_ELEMENTDATA;
    }
}
```

## indexOf

从头开始找
查找在集合某个位置，使用for循环进行

```java
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i < size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
```

在末尾那个位置
```java
public int indexOf(Object o) {
    if (o == null) {
        for (int i = size - 1; i >= 0; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = size - 1; i >=0 ; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
```

## toArray

将集合变为数组
```java
/**
 * 原来的数组 
 * 长度
 * 创建数组的类型
 */
copyOf(
        U[] original, 
        int newLength, 
        Class<? extends T[]> newType)
```
使用System的方法进行数值的复制

```java
/**
 * 原 
 * 开始位置
 * 目标
 * 大小
 */
System.arraycopy(original, 0, copy, 0,
Math.min(original.length, newLength));
```

## elementData

根据下标得到数组中的值，只不过下标已经经过了检查。
```java
private void rangeCheck(int index) {
    if (index >= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); 
}
```

## 删除

删除object，首先找到目标值，然后通过System.copy方法，完成数据的删除。

```java
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index < size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index < size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}
```

fastRemove

```java
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}
```