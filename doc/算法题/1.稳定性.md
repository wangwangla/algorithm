## 时间复杂度

是固定时间的叫做常树操作，比如+-x/,计算时间复杂度只取次数最高项，不要系数，判断好坏需要先判断时间复杂度，在判断实际运行的时间，”常熟项时间“

就是使用理论值比较，如果无法得到结果，就使用实际跑程序

## 额外空间

需要多少的额外空间。有限的几个变量就可以，那么就是o(1)



## 异或怎么理解

无进位的相加

0和任何数字进行异或都是任何数字    

任何数字 异或  任何数字     

交换律：a^b^c  a^c^b  

so一大堆的数，进行异或的顺序无关 

```jav
a,b
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

位置不可以相同   位置相同的时候就会将数据抹掉。



一个数奇数次。，将所有的都进行一次异或操作

偶数次，先进行一次异或，得到不同值a^b，得到它们不相同的

在进行一次异或，数据分为两部分，a or b



a & (~a + 1)提取最右侧的1

![image-20211212224611396](Untitled.assets/image-20211212224611396.png)

# 稳定性

就是排完序之后，尽量保持原理的顺序，对于基本数据类型不会有太大的影响

选择排序不可以保证稳定

冒泡排序是稳定的

插入排序也是

归并排序  

快排不可以

堆不可以

想一下为什么不稳定和稳定



## Hash

hash表在使用的时候都认为是常数级别  数据量是无关的



有序表









## 今日一题

链表回文（1.栈  2.快慢指针   3.有效的几个变量（修改链表））

快慢指针（奇数  偶数到达的位置）

两个数重复

一个数重复



小于的放左边   中间   大于的放右边

1.（数组partition）

2.6个变量  开始头  开始尾    中间头  中间尾    结尾头  结尾尾

操作过程：

一个数据，进一个参数，放头  放尾    

在来一个，比较



赋值链表，链表包含一个rand





然后判断链表有无环

1.使用map，验证这个节点是不是在这个里面

2.快慢指针，如果有环，那么一定会相遇   如果没有环，一定会为null(一定不会大于两圈)

快指针回开头，慢指针在原地  现在都一步一步的走 ，相遇一定在第一个节点处。



链表相交的地方，它走到结尾的地方一定为相同

假设第一个100个节点  第二个80个节点   

那么第一个先走20不，然后它们一起





两个链表有环或者无环，求是不是相交

- 判断是不是环
- 不是
  - 结尾是不是相同
- 是
  - 环之前相交
  - 环之后相交
  - 环入口相交









递归序

递归序是执行三次，先序就是取第一次，中序就是取第二次，后续就是取第三次

前中后就是去取相应位置的数字



非递归的处理：

（1）出栈   进行处理   在压入右   在压入左

（2）后续：

入stack1,出，入stack2,在把左右压进去  循环

（3）中序：





宽度变量

- 宽度变量
- 得到最大个数
  - 首先在1层，将当前节点打印，入队左和右，并记录层数，
  - 如果层数变化，那么就更新一下max值
  - 如果未发生变化，那么就进行累加







怎么判断二叉搜索树？

（1）使用中序遍历，如果是升序，那么就是

（2）分左右树

- 原理是中序遍历

  ```java
  checkBst(Node head){
      if(head == null){
          return true;
      }
      boolean isLeftBST = checkBst(head.left);
      if(head.value <= preValue){
          return false;
      }else{
          prevalue = head.value;
      }
      boolean isRightBST = checkBst(head.left);
  }
  ```

  将打印时机认识是比较时机

  （3）不是递归进行处理



树形DP









#

## 图和贪心

邻接表  临界矩阵



自己实现一种图，然后自己使用自己最熟悉的方式表达，然后将需要处理的问题转换过来