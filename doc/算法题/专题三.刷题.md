



## 今日一题

链表回文（1.栈  2.快慢指针   3.有效的几个变量（修改链表））

快慢指针（奇数  偶数到达的位置）

两个数重复

一个数重复



小于的放左边   中间   大于的放右边

1.（数组partition）

2.6个变量  开始头  开始尾    中间头  中间尾    结尾头  结尾尾

操作过程：

一个数据，进一个参数，放头  放尾    

在来一个，比较



赋值链表，链表包含一个rand





然后判断链表有无环

1.使用map，验证这个节点是不是在这个里面

2.快慢指针，如果有环，那么一定会相遇   如果没有环，一定会为null(一定不会大于两圈)

快指针回开头，慢指针在原地  现在都一步一步的走 ，相遇一定在第一个节点处。



链表相交的地方，它走到结尾的地方一定为相同

假设第一个100个节点  第二个80个节点   

那么第一个先走20不，然后它们一起





两个链表有环或者无环，求是不是相交

- 判断是不是环
- 不是
  - 结尾是不是相同
- 是
  - 环之前相交
  - 环之后相交
  - 环入口相交









递归序

递归序是执行三次，先序就是取第一次，中序就是取第二次，后续就是取第三次

前中后就是去取相应位置的数字



非递归的处理：

（1）出栈   进行处理   在压入右   在压入左

（2）后续：

入stack1,出，入stack2,在把左右压进去  循环

（3）中序：





宽度变量

- 宽度变量
- 得到最大个数
  - 首先在1层，将当前节点打印，入队左和右，并记录层数，
  - 如果层数变化，那么就更新一下max值
  - 如果未发生变化，那么就进行累加







怎么判断二叉搜索树？

（1）使用中序遍历，如果是升序，那么就是

（2）分左右树

- 原理是中序遍历

  ```java
  checkBst(Node head){
      if(head == null){
          return true;
      }
      boolean isLeftBST = checkBst(head.left);
      if(head.value <= preValue){
          return false;
      }else{
          prevalue = head.value;
      }
      boolean isRightBST = checkBst(head.left);
  }
  ```

  将打印时机认识是比较时机

  （3）不是递归进行处理



树形DP









#

## 图和贪心

邻接表  临界矩阵



自己实现一种图，然后自己使用自己最熟悉的方式表达，然后将需要处理的问题转换过来







## 前缀树

就是trie树

trie的功能，求前缀，存在多少个   增加p和e，p就是pass   e就是end 



Node{

​	char [] a;

​	 int p;//这个地方来了多少次

​	int end;//是不是右个结尾的

}





方式二：使用hashMap进行存储

HashMap<char,Node> next;





有多少个重复的，那就使用end  

有多少个前缀，那就是p



删除，对每一个字符进行减减操作







## 贪心

ex1:

有多个项目，怎样才可以使得更多的项目参加

（1）开始最早的，存在反例

（2）时间最短的存在反例

（3）那么就结束最早？？？？？？？



先最早结束的进行排序

然后比较它们的开始点，并更新结束点

```java
int noChongdie(int arr[],int timepoint){
    Arrays.sort(arr,compartor);
    arr.for{
        if(timePoint < arr[index].start){
            timeend++；
               timePoint = arr[index].end；
        }
    }
}
```



贪心技巧：

首先实现一个全排列，这个全排列中包含的有最优解。暴力一定是可以的，但是时间会比较长	







分黄金：

使用halfmap

（先排序）

(2,3,4,5,6)

2+3 4 5 6

2+3+4 5 6

2 + 3 + 4 + 5 6

最后返回一个数字





堆和排序

## 弹出中位数

大根堆   小根堆

首先进入大根堆，下一个数据，如果小于堆顶 ，那么就进如大堆，否则进入小根堆

如果两个size大于2,那么就弹出，进入另一个























